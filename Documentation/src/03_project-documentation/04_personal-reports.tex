\chapter{Personal Reports}

\section{Team Review}
Generally, whenever we had a question, other members were happy to help and could provide helpful input.
The team was motivated to work on the project and work together to get everything done.
It was good that we invested extra time in the beginning, to set up a good architecture and have clean code, which made it very easy to create new features/endpoints.
There were times when it was a little challenging working in a team because of waiting dependencies, where one had to wait until someone finished something before you could continue working, which caused some delays.
Nevertheless, we managed very well, especially after noticing this issue and setting internal deadlines during the spring to prevent this, and it got much better.
After the large documentation block, we all wanted to start coding and focused less on creating informative Jira tickets.
Minimal task descriptions often lead to further questions or having to change something again.
Pascal-dependency was something we could improve on in the future, as he was often the person we contacted to answer questions, give more input on tasks and review our changes.
In the last weeks, we agreed on trying to reduce this dependency with the usage of public chats, asking questions as comments on issues instead of direct messages.
If we'd start the project from new again, we'd invest time into frontend testing, as nearly all our bugs were caused by the frontend, and we don't have any automated testing there.

\section{David}
Overall I'm happy with the whole project and enjoyed working on it.
I had the opportunity to learn new technologies (Kotlin, jOOQ, ktor, pinia) and improve my knowledge of already known ones (javascript, vue.js).
In a future project, I'd plan out my time better to prevent it all heaping up on the weekend and try to spread it out more under the week, which makes achieving the deadlines easier.
In the beginning, I had to ask for help regarding certain technologies, but it became less with time after working with them for a while.
In these past weeks, I feel like I've improved my skill set and can take my learnings with me to the next project.
My highlight was seeing everything coming together from the original idea and then being able to play a round of Jass after a few weeks.

\section{Pascal}
Overall, I really enjoyed our project and have no major complaints.
We chose a very adequate tech stack for our problem scope, and I wouldn't change any technology when starting over.
My personal highlight was the last three weeks when everybody got to work on new features, and we were able to extend our software without any significant roadblocks.
However, there is one thing I would do differently, the requirements engineering.
I tried my best to present reasonable requirements in my role as product owner, but that wasn't enough.
We should've prioritized the requirements from the beginning and spent more time questioning potential end-users to tailor our solution in a better way.

\section{Jamie}
With this project, I had the opportunity to get to know a lot of new technologies.
At the beginning of the project, I was hesitant to ask for help, which created some delays.
I learned that there is a balance of knowing when you should ask for help.
For future projects, I think I would invest more time in the requirement engineering and time management aspect of the project.

\section{Marcel}
I enjoyed working on the project, and I am happy with the end result.
I was able to deepen my knowledge of Kotlin, Vue.js and TypeScript and got to learn a cool framework with Ktor.
I could also bring my knowledge of SQL into the project and implemented all the database migrations.
In the middle of the project I did not always put enough time into the project, which meant not always meeting my sprint goals.
I was able to correct this for the last half of the project and was almost always able to get my tasks done within a sprint.
This project was also my first contact with the onion architecture style, as I was previously more familiar with layered architectures that are more tightly coupled to the database.
