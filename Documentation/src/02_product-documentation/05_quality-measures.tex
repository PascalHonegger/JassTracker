\chapter{Quality Measures}

\instructions{
    Describe the quality measures applied in your project as covered in the SEP2 module. Things that might be included in this chapter:
    
    \begin{itemize}
        \item Organizational means like \textit{Merge Requests}, \textit{Definition of Done}, etc.
        \item Tools used to assess the quality of your product (linter, metrics, ...)
        \item Tools used to build and deploy your product (CI/CD)
        \item The \textit{Test Concept} used for testing your product
    \end{itemize}
    
    Try to avoid duplication with other chapters such as the \textit{Project Plan}. Work with cross-references when appropriate.
}

\section{Working with Git}
\begin{itemize}
    \item We use conventional commits
    \item We use Merge Requests in GitLab, direct pushes to master are forbidden
    \item We rebase our commits locally and create a merge commit when merging into master
\end{itemize}

\section{Definition of Done (DoD)}

\subsection{Feature (Defect / Story)}
\begin{itemize}
    \item Acceptance criteria / issue of user story is met 
    \item Code follows best practices and guidelines 
    \item No TODOs without a issue number are allowed 
    \item Project builds without errors or warnings 
    \item Tests are written and all tests are passing 
    \item Peer Code Review performed 
    \item Project deployed on the test environment identical to production platform 
    \item Documentation updated 
    \item Associated with epic and release 
    \item Hours worked on are logged correctly 
\end{itemize}

\subsection{Sprint}
\begin{itemize}
    \item DoD of each item included in the sprint is met 
    \item Product backlog updated 
    \item Sprint marked as ready for the production deployment by the Product Owner 
\end{itemize}

\subsection{Release}
\begin{itemize}
    \item Release is documented and all contining tasks are associated 
    \item Code complete 
    \item Environments are prepared for release 
    \item QA is done \& all issues resolved 
    \item Check that no unintegrated work in progress has been left in any development or staging environment. 
\end{itemize}

\section{Definition of Ready (DoR)}

\subsection{Defect} 
\begin{itemize}
    \item Steps to reproduce 
    \item Severity 
    \item Screenshots 
\end{itemize}

\subsection{Story}
\begin{itemize}
    \item Use-Case (e.g. view current score)
    \item Estimate 
    \item Epic link 
    \item Acceptance criterea list specified 
    \item Should be doable within a week, otherwise try to split it 
\end{itemize}

\section{Test Concept}
\subsection{Unit Tests}
\begin{itemize}
    \item Business Logic will be Unit Tested
    \item Runs on every Push to GitLab, Merging is blocked until failing tests are fixed
    \item Automated
\end{itemize}

\subsection{Usability Tests}
\begin{itemize}
    \item Project will be given to multiple people for testing (Hallway Testing)
    \item Testers should be able to use website without having to ask any questions
    \item Manual
\end{itemize}

\subsection{System Tests}
\begin{itemize}
    \item How full System works together - how components interact
    \item Influenced by Usability Testing
    \item Manual / Automated
    \item Evaluation of automated Frontend Tests (Cypress) to reduce manual testing in Frontend
\end{itemize}

\section{Continuous Integration and Deployment}
We use GitLab for continuous integration and have a pipeline which runs on every commit and builds both frontend and backend.
For the backend, tests are run and a linter for the frontend. If all jobs succeed, a Docker image is built, pushed to the registry and tagged with the current branch name.
Once a merge request is merged into the master branch the pipeline is run again and a Docker image tagged with latest is built.
If that succeeds the new image is automatically deployed to our staging environment with the option to deploy to production with a single click in GitLab. See also \nameref{sec:architecture_deployment}.
